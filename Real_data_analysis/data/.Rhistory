}
W0 <- princ$loadings
hZ <- princ$PCs
rm(princ) ## delete the temporary variable.
parfun_int <- DR.SC:::parfun_int
nK <- length(K)
if(nK>1){
message("Starting parallel computing intial values...")
## set the number of cores in evaluating initial values
num_core <- coreNum
if(Sys.info()[1]=="Windows"){
cl <- makeCluster(num_core)
}else if(Sys.info()[1]=='Linux'){
cl <- makeCluster(num_core, type="FORK")
}else{
cl <- makeCluster(num_core)
}
intList <- parLapply(cl, X=K, parfun_int, Z=hZ, alpha=alpha,int.model=int.model)
stopCluster(cl)
}else{
intList <- list(parfun_int(K, hZ, alpha, int.model=int.model))
}
alpha0List = list()
Mu0List = list()
Sigma0List = list()
ymat = matrix(0, n, nK)
Pi0List = list()
for (kk in 1: nK){
ymat[,kk] <- intList[[kk]]$yveck
alpha0List[[kk]] <-  intList[[kk]]$alpha0k
Mu0List[[kk]] <- intList[[kk]]$Mu0k
Sigma0List[[kk]] <- intList[[kk]]$Sigma0k
Pi0List[[kk]] <- intList[[kk]]$Pi0k
}
rm(intList) ## delete the temporary variable.
if(verbose){
message("-------------------Finish computing inital values------------- ")
}
if(verbose){
verbose <- 1
}else{
verbose <- 0
}
if(verbose)
message("-------------------Starting  ICM-EM algortihm-------------")
if((!is.null(Adj_sp))){
beta0 = matrix(1, length(K), 1)*1.5
resList <- DR.SC:::icmem_heterCpp(X, Adj_sp, ymat,Mu0List, W0, Sigma0List,  Lam_vec0,
alpha0List,  beta_int=beta0, beta_grid=beta_grid, maxIter_ICM, maxIter,
epsLogLik, verbose, !error.heter, diagSigmak, max(K), min(K), coreNum)
}else if(is.null(Adj_sp)){
resList <- DR.SC:::EMmPCpp_heter(X, Pi0List, Mu0List, W0, Sigma0List, Lam_vec0, maxIter, epsLogLik,
verbose, !error.heter, diagSigmak, max(K), min(K), coreNum)
}
toc_heter <- proc.time() - tic
if(verbose) {
message("-------------------Complete!-------------")
message("elasped time is :", round(toc_heter[3], 2))
}
resList$K_set <- K
class(resList) <- "drscObject"
return(resList)
}
DR.SC_coembed <- function(X, q, K, Adj_sp = NULL, pen.const=1, ...){
## X is a gene-by-cell matrix
if(length(K)>1) stop("K must be an integer!")
X <- X[MatrixGenerics::rowVars(X) != 0, ]
X <- X[stringr::str_length(rownames(X)) > 0, ]
X <- X[!duplicated(rownames(X)), ]
cellsN <- colnames(X)
n <- ncol(X)
featuresN <- rownames(X)
X <- Matrix::t(X)
res <- drsc(X=X, q=q, K=K, Adj_sp=Adj_sp, approxPCA=T, ...)
res_select <- res$Objdrsc[[1]]
rm(res)
H <- res_select$hZ
B <- as.matrix((1/rowSums(t(X)) * t(X)) %*% H)
component <- paste0(reduction.name, "_", seq(ncol(H)))
colnames(H) <- component
colnames(B) <- component
rownames(H) <- cellsN
rownames(B) <- featuresN
return(list(cellsCoordinates=H, featuresCoordinates=B))
}
example(DR.SC_fit)
X <- Matrix::t(X)
nPCs <- 10
system.time({
res_drsc <- DR.SC_coembed(as.maxtrix(X), q=nPCs, K=10, verbose=T)
})
res_drsc <- DR.SC_coembed(as.matrix(X), q=nPCs, K=10, verbose=T)
system.time({
res_drsc <- DR.SC_coembed(as.matrix(X), q=nPCs, K=10, verbose=T)
})
DR.SC_coembed <- function(X, q, K, Adj_sp = NULL, reduction.name = "DRSC",pen.const=1, ...){
## X is a gene-by-cell matrix
if(length(K)>1) stop("K must be an integer!")
X <- X[MatrixGenerics::rowVars(X) != 0, ]
X <- X[stringr::str_length(rownames(X)) > 0, ]
X <- X[!duplicated(rownames(X)), ]
cellsN <- colnames(X)
n <- ncol(X)
featuresN <- rownames(X)
X <- Matrix::t(X)
res <- drsc(X=X, q=q, K=K, Adj_sp=Adj_sp, approxPCA=T, ...)
res_select <- res$Objdrsc[[1]]
rm(res)
H <- res_select$hZ
B <- as.matrix((1/rowSums(t(X)) * t(X)) %*% H)
component <- paste0(reduction.name, "_", seq(ncol(H)))
colnames(H) <- component
colnames(B) <- component
rownames(H) <- cellsN
rownames(B) <- featuresN
return(list(cellsCoordinates=H, featuresCoordinates=B))
}
system.time({
res_drsc <- DR.SC_coembed(as.matrix(X), q=nPCs, K=10, verbose=T)
})
ce <- as.data.frame(rbind(res_drsc$featuresCoordinates,res_drsc$cellsCoordinates))
head(ce)
tail(ce)
library(OMIG)
example("OrMIG")
?OrMIG
misList2 <- OrMIG(as.data.frame(Xmis), types, q, verbose=TRUE)
NAE(as.matrix(misList2$DFimp), dat$X, dat$Xmis, group)
str( misList2)
##3. use the markers in SpatialAnno
dir_file <- "https://raw.githubusercontent.com/Shufeyangyi2015310117/SpatialAnno_Analysis/main/Real_data_analysis/Embryo/Datasets/embryo_markers.txt"
marker_spaanno <- read.table(file=url(dir_file))
marker_spaanno <- readLines(file=url(dir_file))
?readLines
marker_spaanno <- readLines(url(dir_file))
marker_spaanno
strsplit(marker_spaanno[1])
strsplit(marker_spaanno[j], split = ">", fixed=T)
j <- 1
strsplit(marker_spaanno[j], split = ">", fixed=T)
strsplit(marker_spaanno[j], split = ">", fixed=T)[[1]][2]
j <- 2
strsplit(marker_spaanno[j], split = ",", fixed=T)[[1]]
tmp <- strsplit(marker_spaanno[j], split = ",", fixed=T)[[1]]
gsub("\\s+", " ", tmp)
cleaned_string <- gsub("\\s+", "", tmp)
cleaned_string
strsplit(cleaned_string[1] , split = ":", fixed=T)[[2]]
strsplit(cleaned_string[1] , split = ":", fixed=T)[[1]][2]
cleaned_string[1] <- strsplit(cleaned_string[1] , split = ":", fixed=T)[[1]][2]
cleaned_string
j % 2
j %% 2
markerList_spannao <- list()
for(j in seq_along(marker_spaanno)){
#j <- 1
message("j = ", j)
if(j %% 2!=0){
tmp_celltype <- strsplit(marker_spaanno[j], split = ">", fixed=T)[[1]][2]
}else{
# j <- 2
tmp <- strsplit(marker_spaanno[j], split = ",", fixed=T)[[1]]
cleaned_string <- gsub("\\s+", "", tmp)
cleaned_string[1] <- strsplit(cleaned_string[1] , split = ":", fixed=T)[[1]][2]
}
markerList_spannao[[j]] <- cleaned_string
names(markerList_spannao[[j]]) <- tmp_celltype
}
markerList_spannao
markerList_spannao <- list()
k <- 1
for(j in seq_along(marker_spaanno)){
#j <- 1
message("j = ", j)
if(j %% 2!=0){
tmp_celltype <- strsplit(marker_spaanno[j], split = ">", fixed=T)[[1]][2]
}else{
# j <- 2
tmp <- strsplit(marker_spaanno[j], split = ",", fixed=T)[[1]]
cleaned_string <- gsub("\\s+", "", tmp)
cleaned_string[1] <- strsplit(cleaned_string[1] , split = ":", fixed=T)[[1]][2]
markerList_spannao[[k]] <- cleaned_string
names(markerList_spannao[k]) <- tmp_celltype
k <- k + 1
}
}
markerList_spannao
celltype_vec <- c()
markerList_spannao <- list()
celltype_vec <- c()
k <- 1
for(j in seq_along(marker_spaanno)){
#j <- 1
message("j = ", j)
if(j %% 2!=0){
tmp_celltype <- strsplit(marker_spaanno[j], split = ">", fixed=T)[[1]][2]
celltype_vec <- c(celltype_vec, tmp_celltype)
}else{
# j <- 2
tmp <- strsplit(marker_spaanno[j], split = ",", fixed=T)[[1]]
cleaned_string <- gsub("\\s+", "", tmp)
cleaned_string[1] <- strsplit(cleaned_string[1] , split = ":", fixed=T)[[1]][2]
markerList_spannao[[k]] <- cleaned_string
k <- k + 1
}
}
names(markerList_spannao) <- celltype_vec
markerList_spannao
str(markerList_spannao)
marker_spaanno <- readLines((dir_file))
marker_spaanno
##3. use the markers in SpatialAnno
dir_file <- "https://raw.githubusercontent.com/Shufeyangyi2015310117/SpatialAnno_Analysis/main/Real_data_analysis/Embryo/Datasets/embryo_markers.txt"
marker_spaanno <- readLines((dir_file))
marker_spaanno
simutool::colorbar_adj_transparent("f4978e")
simutool::colorbar_adj_transparent("#f4978e")
?PRECAST::AddParSetting
Spafactor_nc
SpatialAnno::SpatialAnno
`Definitive endoderm`
list('Definitive endoderm'="Def. endoderm", )
library(PRECAST)
CreatePRECASTObject
library(CelliD)
?RunCellHGT
?RunCellHGT
?RunMCA
?RunCellHGT
?glm
n <- 100; p <- 5
X <- matrix(rnorm(n*p), n, p)
y <- rpois(n, 5)
library(stats)
glm1 <- glm(y~0+X, family=poisson())
coef(glm)
coef(glm1)
n <- 100; p <- 5; p1 <- 3
Rf <- matrix(rnorm(n*p1), n, p1)
X <- matrix(rnorm(n*p), n, p)
y <- rpois(n, 5)
colnames(Rf) <- paste0("Rf", 1:ncol(Rf))
X[,1:p1] <- Rf
head(X)
X <- cbind(matrix(rnorm(n*p), n, p), Rf)
head(X)
y <- rpois(n, 5)
glm_ruv_onegene(y, X, colnames(Rf))
return(hy)
# lm1 <- lm(X0 ~ 0 + cbind(M0, Rf))
# coefmat <- coef(lm1)[c(1:nc_M0), ]
# rm(lm1)
# hX <- X0 - M0 %*% coefmat
glm_ruv_onegene <- function(y, X, name_Rf){
library(stats)
glm1 <- glm(y~0+X, family=poisson())
hy <- exp(Rf %*% coef(glm1)[name_Rf])
return(hy)
}
glm_ruv_onegene(y, X, colnames(Rf))
library(stats)
glm1 <- glm(y~0+X, family=poisson())
coef(glm1)
# lm1 <- lm(X0 ~ 0 + cbind(M0, Rf))
# coefmat <- coef(lm1)[c(1:nc_M0), ]
# rm(lm1)
# hX <- X0 - M0 %*% coefmat
glm_ruv_onegene <- function(y, X, name_Rf){
library(stats)
glm1 <- glm(y~0+X, family=poisson())
hy <- exp(Rf %*% coef(glm1)[paste0("X",name_Rf)])
return(hy)
}
glm_ruv_onegene(y, X, colnames(Rf))
hy <- glm_ruv_onegene(y, X, colnames(Rf))
cbind(y, hy)
library(Seurat)
sce <- readRDS(url("https://github.com/feiyoung/DR-SC.Analysis/raw/main/data/DLPFC_data/151676.rds"))
library(SingleCellExperiment)
seu1 <- CreateSeuratObject(counts = sce@assays@data$counts,
meta.data = as.data.frame(colData(sce)),
min.cells = 5, min.features = 5)
seu1
library(Seurat)
sce <- readRDS(url("https://github.com/feiyoung/DR-SC.Analysis/raw/main/data/DLPFC_data/151675.rds"))
seuList <- list()
seuList[[1]] <- CreateSeuratObject(counts = sce@assays@data$counts,
meta.data = as.data.frame(colData(sce)),
min.cells = 5, min.features = 5)
Idents(seuList[[1]]) <- seuList[[1]]$layer_guess_reordered
seuList
?commandArgs
ntop <- 10
ntop <- 10
marker_wilcox <- markerList_ref
# FAST+Harmony to do co-embedding for multiple samples --------------------
library(FAST)
FAST
library(FAST)
FAST_run
?FAST_run
RunHarmonyLouvain
get_sampleID
FAST:::get_sampleID
matlist2mat
rm(list=ls())
library(Seurat)
?CreateSpatialObject
?Seurat::Load10X_Spatial
VlnPlot
ExIPlot
library(PRECAST)
?SpatialFeaturePlot
?SpatialPlot
?getMatrixFromProject
library(ArchR)
?getMatrixFromProject
ArchR:::getGeneScore_ArchR
ArchR:::getGeneScore
make_option
library(PRECAST)
librarY(FAST)
library(FAST)
FAST::get_r2_mcfadden
##
X <- matrix(rnorm(100*10), 100, 10)
row.names(X) <- c(paste0("a",1:50), paste0("b", 1:50))
X
pdistance <- function(Ar, Br) {
An <- rowSums(Ar^2)
Bn <- rowSums(Br^2)
C <- -2 * Ar %*% t(Br)
C <- C + An
C <- t(t(C) + Bn)
rownames(C) <- rownames(Ar)
colnames(C) <- rownames(Br)
return(sqrt(C))
}
d <- pdistance(X[1:5,], X[51:55,])
d
library(dplyr)
%<%
`%<%``
`%<%`` 1
2
*2
?sample
glue::glue("All pathways have less than {minSize} features in common with the data")
X <- MASS::mvrnorm(n=200, mu=rep(0,5), Sigma = GFM:::cor.mat(5, 0.8))
cov(X)
cor(X)
X <- MASS::mvrnorm(n=200, mu=rep(0,5), Sigma = 5*GFM:::cor.mat(5, 0.8))
cov(X)
cor(X)
Y <- scale(X)
cov(Y)
cor(X)
svd(Y)$d^2
eig(cov(Y))$values
eigen(cov(Y))$values
svd(Y)$d
svd(Y/sqrt(nrow(Y)))$d
svd(Y/sqrt(nrow(Y)))$d^2
n.sims=10
### simulate data
p <- ncol(Y)
corr_fun <- function(i, n, p){
set.seed(i)
X1 <- matrix(rnorm(n*p), n, p)
svdX1 <- irlba(A = X1/sqrt(n), nv = q_max)
return(svdX1$d^2)
}
eig.mat.sim <- pbapply::pbsapply(1:n.sims, corr_fun, n=n, p=p)
n <- nrow(Y)
eig.mat.sim <- pbapply::pbsapply(1:n.sims, corr_fun, n=n, p=p)
# X is a cell-by-gene matrix
require(ggplot2)
library(irlba)
eig.mat.sim <- pbapply::pbsapply(1:n.sims, corr_fun, n=n, p=p)
q_max=50
eig.mat.sim <- pbapply::pbsapply(1:n.sims, corr_fun, n=n, p=p)
if(q_max > ncol(X)) q_max <- ncol(X)
eig.mat.sim <- pbapply::pbsapply(1:n.sims, corr_fun, n=n, p=p)
q_max
X1 <- matrix(rnorm(n*p), n, p)
svdX1 <- irlba(A = X1/sqrt(n), nv = q_max)
X1/sqrt(n)
q_max
svdX1 <- irlba(A = X1/sqrt(n), nv = q_max)
if(q_max > ncol(X)) q_max <- ncol(X)-1
eig.mat.sim <- pbapply::pbsapply(1:n.sims, corr_fun, n=n, p=p)
q_max
ncol(X)-1
q_max <- ncol(X)-1
eig.mat.sim <- pbapply::pbsapply(1:n.sims, corr_fun, n=n, p=p)
eig.mat.sim
dat <- data.frame(q=1:length(dvec), eig_value=dvec, eig_sim = rowMeans(eig.mat.sim))
svdX <- irlba(A = Y/sqrt(n), nv = q_max)
dvec <- svdX$d^2 ## is the eigenvalues of correlation matrix
dat <- data.frame(q=1:length(dvec), eig_value=dvec, eig_sim = rowMeans(eig.mat.sim))
dat
ggplot(data=dat, aes(x=q, y=eig_value)) + geom_line(linewidth=1) +
geom_point(size=1.5) + theme_classic(base_size = 16)
ggplot(data=dat, aes(x=q, y=eig_value)) + geom_line(linewidth=1) +
geom_point(size=1.5) + geom_line(aes(x=q, y=eig_sim), color='red')
dat
?FindVariableFeatures
which(dat$eig_sim>dat$eig_value)[1]
attr("q_est", dat)
attr(dat, "1")
library(msigdbr)
?msigdbr
## transfer the embsem to symbol for gene names
FAST::
tic <- proc.time()
hotelling.pathway.test
?irlba::irlba
?RunUMAP
?DimPlot
?CreateDimReducObject
rotate_90_clockwise
?DimPlot
?sapply
?future_map
library(furrr)
library(future)
?future_map
library(stringr)
str_detect
diagnostic.cor.eigs
PRECAST:::filter
library(msigdbr) # for gathering gene sets
msigdbr_collections()
selectIntFeatures
library(PRECAST)
selectIntFeatures
i <- 1
paste0("HCC", i, "_seu.RDS")
getXList
PRECAST:::getXList
setwd("E:/Research paper/IntegrateDRcluster/AnalysisCode/PRECAST_Analysis/Real_data_analysis/data")
library(DR.SC)
library(Seurat)
library(Matrix)
library(dplyr)
library(PRECAST)
posList <- list()
seuList <- list()
for(iter in 1: 4){
# iter <- 1
hcc <- readRDS(paste0("HCC", iter, "_seu.RDS"))
seuList[[iter]] <- hcc
posList[[iter]] <- cbind(row=hcc$row, col=hcc$col)
}
str(posList)
seuList
load('HCC4_spatialFeatureList.rds')
selectIntFeatures <- PRECAST:::selectIntFeatures
getXList <- PRECAST:::getXList
genelist <- selectIntFeatures(seuList, spaFeatureList)
length(unique(genelist))
genelist
datList <- getXList(seuList, genelist)
str(datList[[1]])
metadataList <- lapply(seuList, function(x) x@meta.data)
XList <- datList$XList
posList <- datList$posList
indexList <- datList$indxList
## Integration analysis using PRECAST ############################################################
q <- 15; K <- 2:11
# Integrate 12 samples
tic <- proc.time() #
set.seed(1)
time_used_chooseK <- toc[3] - tic[3]
## Integration analysis using PRECAST ############################################################
q <- 15; K <- 9# 2:11
# Integrate 12 samples
tic <- proc.time() #
set.seed(1)
resList <- ICM.EM(XList, posList=posList, q=q, K=K,
platform = 'Visium',maxIter = 30,
Sigma_equal =F, verbose=T, coreNum = 5, coreNum_int = 5)
toc <- proc.time()
time_used_chooseK <- toc[3] - tic[3]
str(resList)
table(resList[[1]][[1]]$clusters[[1]])
table(resList[[1]][[1]]$cluster[[1]])
table(resList[[1]][[1]][[1]]$cluster[[1]])
table(resList[[1]]$cluster[[1]])
table(resList[[1]]$cluster[[2]])
table(resList[[1]]$cluster[[3]])
table(resList[[1]]$cluster[[4]])
url_hcc <- "https://github.com/feiyoung/PRECAST_Analysis/raw/main/Real_data_analysis/data/"
posList <- list()
seuList <- list()
for(iter in 1: 4){
# iter <- 1
message("iter = ", iter)
hcc <- readRDS(paste0(url_hcc,"HCC", iter, "_seu.RDS"))
seuList[[iter]] <- hcc
posList[[iter]] <- cbind(row=hcc$row, col=hcc$col)
}
url_hcc <- "https://github.com/feiyoung/PRECAST_Analysis/raw/main/Real_data_analysis/data/"
posList <- list()
seuList <- list()
for(iter in 1: 4){
# iter <- 1
message("iter = ", iter)
hcc <- readRDS(url(paste0(url_hcc,"HCC", iter, "_seu.RDS")))
seuList[[iter]] <- hcc
posList[[iter]] <- cbind(row=hcc$row, col=hcc$col)
}
