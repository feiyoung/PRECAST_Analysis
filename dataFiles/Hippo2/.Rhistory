## try DR-SC^2#####################
library(iDR.SC2)
ClusterMethodNames <- c("Scanorama-SC-MEB", "Scanorama-Louvain", "scGen-SC-MEB",
"scGen-Louvain","scVI-SC-MEB", "scVI-Louvain",
paste0("MEFISTO", c("-SC-MEB", "-Louvain")))
ClusterMethodNames
library(iDR.SC2)
datList <-gendataInte_sp()
Adj <- getAdj_auto(datList$pos1)
library(Matrix)
D <- as(diag(rowSums(Adj)), "sparseMatrix")
a <- qr.solve(D-Adj)
Adj[1:10, 1:10]
D[1:10, 1:10]
max(D)
min(D)
min(rowSums(Adj))
datList <-gendataInte_sp(5,5)
Adj <- getAdj_auto(datList$pos1)
library(Matrix)
D <- as(diag(rowSums(Adj)), "sparseMatrix")
a <- qr.solve(D-Adj)
eig(D-Adj)
eigen(D-Adj)
datList <-gendataInte_sp(10,10)
Adj <- getAdj_auto(datList$pos1)
library(Matrix)
D <- as(diag(rowSums(Adj)), "sparseMatrix")
a <- qr.solve(D-Adj)
eigen(D-Adj)
## Conduct iDR-SC
library(iDR.SC)
idrsc
library(iDR.SC)
simutool::colorbar_adj_transparent(c('#1CE6FF','#FF34FF','#FF4A46'), alpha=1)
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
gg_color_hue(2)
gg_color_hue(2)
simutool::colorbar_adj_transparent(gg_color_hue(3), alpha=1)
colorbar_adj_transparent
# colorbar_adj_transparent(cols, alpha=1)
colorbar_adj_transparent <- function(colors, alpha=0.6, plot=T){
require(colorspace)
ramp.list = adjust_transparency(colors,   alpha = alpha)
print(ramp.list)
if(plot==T){
barplot(rep(1, length(ramp.list)), axes = FALSE, space = 0, col = ramp.list)
}
return(ramp.list)
}
###iDR-SC choose 10 clusters###
#p1 <- tSNE_samplePlot(hZ_tsne_idrsc_cluster10, sampleID= sampleID_fac, cols=cols_sample)
base_cols <- gg_color_hue(3)
cols_sample <- rep(NA, 12)
cols_sample[1:4] <- sapply(1:4, function(j) colorbar_adj_transparent(base_cols[1], alpha=1-(j-1)*0.2))
cols_sample
cols_sample[5:8] <- sapply(1:4, function(j) colorbar_adj_transparent(base_cols[2], alpha=1-(j-1)*0.2))
cols_sample[9:12] <- sapply(1:4, function(j) colorbar_adj_transparent(base_cols[3], alpha=1-(j-1)*0.2))
cols_sample
pt_size_sample
# simutool::colorbar_adj_transparent(cols_cluster)
cols_sample <- gg_color_hue(2)
scater::calculateTSNE
library(scater)
calculateTSNE
showMethods(calculateTSNE)
scater:::calculateTSNE()
scater:::calculateTSNE
calculateTSNE
?calculateTSNE
plot(sin(100*seq(-2,2, by=0.01)))
plot(sin(100*seq(-2,2, by=0.1)), type='o')
plot(sin(100*seq(-2,2, by=0.1)), type='l')
plot(sin(100*seq(-2,2, by=1)), type='l')
plot(sin(1000*seq(-2,2, by=1)), type='l')
plot(sin(1000*seq(-2,2, by=0.01))*pi, type='l')
MixPPCA:::
MixPPCA:::selectFacNumber
selectFacNumber <- function(X, qmax=15){
mnlamjFun <- function(eigvals, j){
p <- length(eigvals)
lamj <- eigvals[j]
Sum <- 0
for(l in (j+1):p){
Sum <- Sum + 1/(eigvals[l] - lamj)
}
res <- Sum + 1/ ((3*lamj + eigvals[j+1])/4 - lamj)
return(res/(p-j))
}
mtnlamjFun <- function(n, eigvals, j){
p <- length(eigvals)
rhojn <-  (p-j)/(n-1)
res <- -(1-rhojn)/ eigvals[j] + rhojn * mnlamjFun(eigvals, j)
return(res)
}
##Reference: Fan, J., Guo, J., & Zheng, S. (2020). Estimating number of factors by adjusted eigenvalues thresholding. Journal of the American Statistical Association, 1-10.
n <- nrow(X)
p <- ncol(X)
corMat <- cor(X)
evalues <- eigen(corMat)$values
hq1 <- sum(evalues>1+sqrt(p/(n-1)))
# ajdust the eigvalues
adj.eigvals <- sapply(1:(p-1), function(j) -1/mtnlamjFun(n, evalues, j))
hq <- sum(adj.eigvals >1) # overselect
return(hq)
}
X <- matrix(rnorm(100*50,)100, 50)
X <- matrix(rnorm(100*50), 100, 50)
selectFacNumber(X)
X <- matrix(rnorm(100*10), 100, 10) %*% matrix(rnorm(10*100, 3, sd=1), 10, 100)
selectFacNumber(X)
scdx <- svd(X, nu=10, nv=10)
X <- scdx$u %*% diag(scdx$d) %*% t(scdx$v)
diag(scdx$d)
X <- scdx$u %*% diag(scdx$d[1:10]) %*% t(scdx$v)
selectFacNumber(X)
X <- scdx$u %*% diag(seq(11, 2, by=-1) *scdx$d[1:10]) %*% t(scdx$v)
selectFacNumber(X)
svd(X)$d
mnlamjFun <- function(eigvals, j){
p <- length(eigvals)
lamj <- eigvals[j]
Sum <- 0
for(l in (j+1):p){
Sum <- Sum + 1/(eigvals[l] - lamj)
}
res <- Sum + 1/ ((3*lamj + eigvals[j+1])/4 - lamj)
return(res/(p-j))
}
mtnlamjFun <- function(n, eigvals, j){
p <- length(eigvals)
rhojn <-  (p-j)/(n-1)
res <- -(1-rhojn)/ eigvals[j] + rhojn * mnlamjFun(eigvals, j)
return(res)
}
##Reference: Fan, J., Guo, J., & Zheng, S. (2020). Estimating number of factors by adjusted eigenvalues thresholding. Journal of the American Statistical Association, 1-10.
n <- nrow(X)
p <- ncol(X)
corMat <- cor(X)
evalues <- eigen(corMat)$values
evalues
# ajdust the eigvalues
adj.eigvals <- sapply(1:(p-1), function(j) -1/mtnlamjFun(n, evalues, j))
adj.eigvals
datList <- GFM::gendata()
X <- datList$X
selectFacNumber(X)
datList <- GFM::gendata(q=8)
X <- datList$X
selectFacNumber(X)
## Conduct iDR-SC
library(iDR.SC)
idrsc
library(Seurat)
?NormalizeData
?DR.SC_fit
summary(colSums(Adj_sp))
library(DR.SC)
spatialPlotClusters
example(spatialPlotClusters)
spatialPlotClusters
spatialPlotClusters
library(DR.SC)
spatialPlotClusters
library(DR.SC2)
drsc2
library(DR.SC)
DR.SC_fit
DR.SC:::drsc
DR.SC:::mycluster
DR.SC:::parfun_int
library(iDR.SCv3)
DR.SC:::spatialPlotClusters
idrsc
DR.SC:::getAdj_auto
getAdj_auto <- function(pos, lower.med=4, upper.med=6, radius.upper= 100){
if (!inherits(pos, "matrix"))
stop("method is only for  matrix object!")
radius.lower <- 1
Adj_sp <- getneighborhood_fast(pos, radius=radius.upper)
Med <- summary(Matrix::rowSums(Adj_sp))['Median']
if(Med < lower.med) stop("The radius.upper is too smaller that cannot find median neighbors greater than 4.")
start.radius <- 1
Med <- 0
message("Find the adjacency matrix by bisection method...")
while(!(Med >= lower.med && Med <=upper.med)){ # ensure that each spot has about 4~6 neighborhoods in median.
Adj_sp <- getneighborhood_fast(pos, radius=start.radius)
Med <- summary(Matrix::rowSums(Adj_sp))['Median']
if(Med < lower.med){
radius.lower <- start.radius
start.radius <- (radius.lower + radius.upper)/2
}else if(Med >upper.med){
radius.upper <- start.radius
start.radius <- (radius.lower + radius.upper)/2
}
message("Current radius is ", round(start.radius, 2))
message("Median of neighborhoods is ", Med)
}
return(Adj_sp)
}
DR.SC2::drsc2
getXList
selectIntFeatures
selectIntFeatures
?CreateSpatialPCAObject
library(SPARK)
?CreateSPARKObject
install.packages('DR.SC')
example("DR.SC")
example(DR.SC)
library(DR.SC)
example(DR.SC)
DR.SC:::wpca
?mclust::Mclust
DR.SC2::drsc2
library(DR.SC)
?getAdj_auto
spatialPlotClusters
library(data.table)
?fread
SpatialPCA::plot_cluster
library(Seurat)
library(Seurat)
c( "#FD7446" ,"#709AE1", "#31A354","#9EDAE5",
"#DE9ED6" ,"#BCBD22", "#CE6DBD" ,"#DADAEB" ,
"yellow", "#FF9896","#91D1C2", "#C7E9C0" ,
"#6B6ECF", "#7B4173", "green4")
getXList
iDR.SC::getXList
library(Seurat)
drsc2
DR.SC2::drsc2
1186/60
library(iDR.SC)
### two data source
q <- 10; K <- 4
dat <- gendataInte_sp(width1 = 20, height1 = 20,height2=21, width2=21, p=100,q=q, K=K, sigma2 = 9,
beta=c(0.5, 1.0))
AdjList <- lapply(list(dat$pos1, dat$pos2), getAdj_reg, platform='ST')
message(sapply(AdjList, dim), '\n')
resList <- idrsc(list(dat$X1, dat$X2), list(dat$pos1, dat$pos2), q, K, maxIter = 30,
platform='ST',
Sigma_equal =T, Sigma_diag=T, error_heter = T, seed = 1, Sp2=T, verbose=T)
resList <- idrsc(list(dat$X1, dat$X2), posList=list(dat$pos1, dat$pos2), q=q, K=K, maxIter = 30,
platform='ST',
Sigma_equal =T, Sigma_diag=T, error_heter = T, seed = 1, Sp2=T, verbose=T)
mclust::adjustedRandIndex(unlist(resList[[1]]$cluster), unlist(dat$cluster))
XList <- lapply(XList, scale, scale=F)
XList <- list(dat$X1, dat$X2)
XList <- lapply(XList, scale, scale=F)
Xmat <- scale(rbind(XList[[1]], XList[[2]]), center = F, scale = T)
XList <- list(Xmat[datList$indxList[[1]],], Xmat[datList$indxList[[2]],])
indxList <- list(1:nrow(XList[[1]]), (nrow(XList[[1]])+): (nrow(XList[[1]])+nrow(XList[[2]])))
indxList <- list(1:nrow(XList[[1]]), (nrow(XList[[1]])+1): (nrow(XList[[1]])+nrow(XList[[2]])))
XList <- list(Xmat[datList$indxList[[1]],], Xmat[datList$indxList[[2]],])
XList <- list(Xmat[indxList[[1]],], Xmat[indxList[[2]],])
resList <- idrsc(XList, posList=list(dat$pos1, dat$pos2), q=q, K=K, maxIter = 30,
platform='ST',
Sigma_equal =T, Sigma_diag=T, error_heter = T, seed = 1, Sp2=T, verbose=T)
mclust::adjustedRandIndex(unlist(resList[[1]]$cluster), unlist(dat$cluster))
resList1 <- idrsc(list(dat$X1, dat$X2), posList=list(dat$pos1, dat$pos2), q=q, K=K, maxIter = 30,
platform='ST',
Sigma_equal =T, Sigma_diag=T, error_heter = T, seed = 1, Sp2=T, verbose=T)
sapply(resList1[[1]], table)
sapply(resList1[[1]]$cluster, table)
sapply(resList[[1]]$cluster, table)
resList1 <- idrsc(list(dat$X1, dat$X2), posList=list(dat$pos1, dat$pos2), q=q, K=K, maxIter = 30,
platform='ST',
Sigma_equal =F, Sigma_diag=T, error_heter = T, seed = 1, Sp2=T, verbose=T)
resList <- idrsc(XList, posList=list(dat$pos1, dat$pos2), q=q, K=K, maxIter = 30,
platform='ST',
Sigma_equal =F, Sigma_diag=T, error_heter = T, seed = 1, Sp2=T, verbose=T)
mclust::adjustedRandIndex(unlist(resList[[1]]$cluster), unlist(dat$cluster))
sapply(resList[[1]]$cluster, table)
mclust::adjustedRandIndex(unlist(resList1[[1]]$cluster), unlist(dat$cluster))
sapply(resList1[[1]]$cluster, table)
dat <- gendataInte_sp(width1 = 20, height1 = 20,height2=21, width2=21, p=100,q=q, K=K, sigma2 = 9,
beta=c(0.5, 1.0), seed = 10)
AdjList <- lapply(list(dat$pos1, dat$pos2), getAdj_reg, platform='ST')
message(sapply(AdjList, dim), '\n')
resList1 <- idrsc(list(dat$X1, dat$X2), posList=list(dat$pos1, dat$pos2), q=q, K=K, maxIter = 30,
platform='ST',
Sigma_equal =F, Sigma_diag=T, error_heter = T, seed = 1, Sp2=T, verbose=T)
XList <- lapply(XList, scale, scale=F)
Xmat <- scale(rbind(XList[[1]], XList[[2]]), center = F, scale = T)
XList <- list(Xmat[indxList[[1]],], Xmat[indxList[[2]],])
resList <- idrsc(XList, posList=list(dat$pos1, dat$pos2), q=q, K=K, maxIter = 30,
platform='ST',
Sigma_equal =F, Sigma_diag=T, error_heter = T, seed = 1, Sp2=T, verbose=T)
mclust::adjustedRandIndex(unlist(resList[[1]]$cluster), unlist(dat$cluster))
sapply(resList[[1]]$cluster, table)
mclust::adjustedRandIndex(unlist(resList1[[1]]$cluster), unlist(dat$cluster))
sapply(resList1[[1]]$cluster, table)
XList <- list(dat$X1, dat$X2)
indxList <- list(1:nrow(XList[[1]]), (nrow(XList[[1]])+1): (nrow(XList[[1]])+nrow(XList[[2]])))
XList <- lapply(XList, scale, scale=F)
Xmat <- scale(rbind(XList[[1]], XList[[2]]), center = F, scale = T)
XList <- list(Xmat[indxList[[1]],], Xmat[indxList[[2]],])
resList <- idrsc(XList, posList=list(dat$pos1, dat$pos2), q=q, K=K, maxIter = 30,
platform='ST',
Sigma_equal =F, Sigma_diag=T, error_heter = T, seed = 1, Sp2=T, verbose=T)
mclust::adjustedRandIndex(unlist(resList[[1]]$cluster), unlist(dat$cluster))
sapply(resList[[1]]$cluster, table)
mclust::adjustedRandIndex(unlist(resList1[[1]]$cluster), unlist(dat$cluster))
sapply(resList1[[1]]$cluster, table)
sd(dat$X1[,1])
sd(XList[[1]][,1])
SpatialPCA::plot_cluster
c( "#FD7446" ,"#709AE1", "#31A354","#9EDAE5",
"#DE9ED6" ,"#BCBD22", "#CE6DBD" ,"#DADAEB" ,
"yellow", "#FF9896","#91D1C2", "#C7E9C0" ,
"#6B6ECF", "#7B4173", "darkseagreen", "#BCBDDC" ,"#BDBDBD", "#C6DBEF",
"#FDD0A2" ,"#C7E9C0" ,"#DADAEB", "#D9D9D9")
color_used = c( "#FD7446" ,"#709AE1", "#31A354","#9EDAE5",
"#DE9ED6" ,"#BCBD22", "#CE6DBD" ,"#DADAEB" ,
"yellow", "#FF9896","#91D1C2", "#C7E9C0" ,
"#6B6ECF", "#7B4173", "green4", 'blue', pal1(max_n))
library(ggthemes)
palettes <- ggthemes_data[["tableau"]][["color-palettes"]][["regular"]]
names(palettes)
pal1 <- tableau_color_pal("Classic 20")
max_n <- attr(pal1, "max_n")
pal2 <- tableau_color_pal("Classic Blue-Red 12")
max_n2 <- attr(pal2, "max_n")
cols_cluster <- c(pal1(max_n), pal2(max_n2)[c(1,3,8,9,12)])
color_used = c( "#FD7446" ,"#709AE1", "#31A354","#9EDAE5",
"#DE9ED6" ,"#BCBD22", "#CE6DBD" ,"#DADAEB" ,
"yellow", "#FF9896","#91D1C2", "#C7E9C0" ,
"#6B6ECF", "#7B4173", "green4", 'blue', pal1(max_n))
color_used
color_used
## Conduct iDR-SC
library(iDR.SCv3)
idrsc
cancor(wpca(dat$X1,10, F)$PCs, wpca(XList[[1]], 10, F)$PCs)
cancor(wpca(dat$X1,10, F)$PCs, wpca(scale(dat$X1), 10, F)$PCs)
FindIntegrationAnchors
library(Seurat)
?SCTransform
data("pbmc_small")
SCTransform(object = pbmc_small)
pbmc_small
drsc2
# Try　DR-SC2 wiht sum-zero constraint -------------------------------------
library(DR.SC2)
drsc2
selectIntFeatures
SpatialPCA_buildKernel
library(SpatialPCA)
SpatialPCA_buildKernel
idrsc
idrsc
getXList
idrsc
get_fastMNN
?require(batchelor)
require(batchelor)
?fastMNN
drsc2
# Try　DR-SC2 wiht sum-zero constraint -------------------------------------
library(DR.SC2)
drsc2
idrsc2
jpg
jpeg
hist(1:10)
X <- cbind(1:5,2:6)
scale(X)
scale(X, center=F)
apply(X, 2, sd)
apply(X, 2, var)
XList <- list(cbind(1:5, 2:6), cbind(7:20, 8:21))
XList <- lapply(XList, scale, scale=F)
get_indexList <- function(alist){
nsample <- length(alist)
nr <- 0
indexList <- list()
for(i in 1:nsample){
indexList[[i]] <- (nr+1):(nrow(alist[[i]] )+nr)
nr <- nr + nrow(alist[[i]] )
}
return(indexList)
}
indexList <- get_indexList(XList)
Xmat <- NULL
for(r in 1:r_max){
Xmat <- rbind(Xmat, XList[[r]])
}
r_max
r_max <- 2
Xmat <- NULL
for(r in 1:r_max){
Xmat <- rbind(Xmat, XList[[r]])
}
## Joint scale on Xmat
Xmat2 <- scale(Xmat, center=F)
Xmat2
apply(Xmat, 2, sd)
library(SPARK)
?spark.ai
?CreateSPARKObject
library(SpatialPCA)
?CreateSpatialPCAObject
CreateSpatialPCAObject
?CreateSeuratObject
library(iDR.SC)
?idrsc
?DR.SC::selectModel
getZ <- function(height=30, width=30, p =100, q=10, K=7,  G=4, beta=1, sigma2=1, tau=8, seed=1, view=T){
# height <- 70
# width <- 70
# G <- 4
# beta <- 1.0
# K <- 7
# q <- 10
# p <- 1000
if(q <2) stop("error:gendata_sp::q must be greater than 2!")
require(GiRaF)
require(MASS)
n <- height * width # # of cell in each indviduals
## generate deterministic parameters, fixed after generation
set.seed(1)
# sigma2 <- 1
Lambda <- sigma2*abs(rnorm(p, sd=1))
W1 <- matrix(rnorm(p*q), p, q)
W <- qr.Q(qr(W1))
mu <- matrix(0, q,  K)
diagmat = array(0, dim = c(q, q, K))
for(k in 1:K){
mu[,k] <- k*tau
diagmat[,,k] <- diag(rep(1, q))
}
Mu <- t(mu)
Sigma <- diagmat
set.seed(seed)
# generate the spatial dependence for state variable y, a hidden Markov RF
y <- sampler.mrf(iter = n, sampler = "Gibbs", h = height, w = width, ncolors = K, nei = G, param = beta,
initialise = FALSE, view = view)
y <- c(y) + 1
Z <- matrix(0, n, q)
for(k in 1:K){
nk <- sum(y==k)
Z[y==k, ] <- MASS::mvrnorm(nk, Mu[k,], Sigma[,,k])
}
return(list( Z=Z, cluster=y))
}
# use Seruat tool to plot an illustrated heatmap
library(Seurat)
n <- 900; p <- 100
X <- matrix(rnorm(n*p), n, p)
counts <- t(X)
colnames(counts) <- paste0('cell', 1:ncol(counts))
row.names(counts) <- paste0('gene', 1:nrow(counts))
dat_Se <- CreateSeuratObject(counts=counts)
dat_Se[['RNA']]@data <- counts
dat_Se <- ScaleData(dat_Se)
scale.data <- dat_Se[['RNA']]@scale.data
scale.data[1:(5*7),] <- rnorm(900, 0, sd=0.1)
cell <- NULL
for(j in 1:6){
scale.data[((j-1)*5+1):(j*5),((j-1)*100+1):(j*100) ]  <- 1.2 +rnorm(100, 0, sd=0.2)
cell <- c(cell, rep(j, 100))
}
scale.data[((7-1)*5+1):(7*5), 601:900] <- 1.2+rnorm(300 ,0, sd=0.2)
cell <- c(cell, rep(7, 300))
dat_Se[['RNA']]@scale.data <- scale.data
Idents(dat_Se) <- factor(cell)
col.base <- c("hotpink","mediumorchid2","#F4A582","#B8E186","#8dd3c7","wheat","lightskyblue")
## Plot heatmap:
DoHeatmap(dat_Se,features = row.names(scale.data)[1:35],  label = F,
group.colors=col.base)
col.base <- c("#4374A5", "#F08A21","#2AB673", "#FCDDDE",  "#70B5B0", "#E04D50", "#DFE0EE")
DoHeatmap(dat_Se,features = row.names(scale.data)[1:35],  label = F,
group.colors=col.base)
SC.MEB
iDR.SC::selectIntFeatures
dir_current <- "E:\\Research paper\\IntegrateDRcluster\\PRECAST_Analysis\\"
source(paste0(dir_current, "//utility_funcs.R"))
##### 2a #####
setwd(paste0(dir_current, "brain12\\") )
paste0(dir_current, "brain12\\")
##### 2a #####
setwd(paste0(dir_current, "dataFiles\\brain12\\") )
setwd(paste0(dir_current, "dataFiles\\HCC4\\") )
setwd(paste0(dir_current, "dataFiles\\Bulb16\\") )
#### Start Assignment plot
load("clusterAll_tmpList_Method8_Bulb16_rep2_merge70.rds")
setwd(paste0(dir_current, "dataFiles\\Hippo2\\") )
load("hZ_umap3_tmpList_Method8_Hip2_merge70.rds")
